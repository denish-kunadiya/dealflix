-- Custom types
create type public.pda_service as enum ('fannie-mae', 'freddie-mac');
create type public.app_role as enum ('admin', 'photographer');
create type public.app_permission as enum (
  'profile.read',
  'profile.update',
  'report.create',
  'report.read',
  'report.update',
  'report.delete',
  'order.create',
  'order.read',
  'order.update',
  'order.delete'
);
create type public.order_status as enum (
  'INITIATED',
  'AVAILABLE',
  'ASSIGNED',
  'IN_PROGRESS',
  'QC_SUBMITTED',
  'QC_ACCEPTED',
  'QC_REJECTED',
  'GSE_SUBMITTED',
  'GSE_ACCEPTED',
  'GSE_REJECTED',
  'COMPLETE'
);
create type public.report_status as enum ('COMPLETE', 'INCOMPLETE');

-- PROPERTY DATA API AUTH
create table public.pda_auth (
  service pda_service primary key,
  data jsonb not null,
  created_at timestamptz not null default (timezone('utc', now())),
  updated_at timestamptz not null default (timezone('utc', now()))
);
comment on table public.pda_auth is 'Auth data of Government Special Entities API';

-- PROFILE
create table public.profile (
  user_id uuid references auth.users not null primary key, -- UUID from auth.users,
  first_name varchar,
  last_name varchar,
  postal_code varchar,
  phone varchar,
  work_radius int not null default 50,
  created_at timestamptz not null default (timezone('utc', now())),
  updated_at timestamptz not null default (timezone('utc', now())),
  blocked_at timestamptz default null,
  deleted_at timestamptz default null
);

-- USER ROLE
create table public.role (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  role app_role not null,
  unique (user_id, role)
);
comment on table public.role is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role app_role not null,
  permission app_permission not null,
  unique (role, permission)
);
comment on table public.role is 'Application permissions for each role.';

-- ORDERS
create table public.order (
  id uuid primary key default gen_random_uuid(),
  creator_id uuid references auth.users not null,
  assignee_id uuid references auth.users default null,
  status varchar not null default 'INITIATED',

  street_address varchar not null,
  city varchar not null,
  state varchar not null,
  postal_code varchar not null,
  floors_number int not null,

  onsite_contact_name varchar not null,
  onsite_contact_phone varchar not null,
  onsite_contact_email varchar not null,

  deliver_email varchar not null,
  delivery_company varchar,
  delivery_name varchar,
  delivery_phone varchar,

  borrower_name varchar not null,
  amc_name varchar not null,
  lender_name varchar not null,
  lender_id varchar not null,
  lender_loan_id varchar not null,

  type varchar not null,
  is_rush boolean default false,

  created_at timestamptz not null default (timezone('utc', now())),
  updated_at timestamptz not null default (timezone('utc', now()))
);

-- REPORT
create table public.report (
  id uuid primary key default gen_random_uuid(),
  order_id uuid references public.order not null,
  user_id uuid references auth.users not null,
  inspection_id varchar default null,
  inspection_report jsonb default null,
  ispection_status report_status default 'INCOMPLETE',
  validation_errors jsonb default null,
  required_photos jsonb default null,
  missing_image_files jsonb default null,
  created_at timestamptz not null default (timezone('utc', now())),
  updated_at timestamptz not null default (timezone('utc', now()))
);

-- FUNCTIONS
-- set updated_at
create or replace function public.trigger_set_updated_at() returns trigger as $$
  begin
    new.updated_at = (timezone('utc', now()));
    return new;
  end
$$ language plpgsql;

-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  where role_permissions.permission = authorize.requested_permission
    and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

-- inserts a row into public.users and assigns roles
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profile (user_id, first_name, last_name, phone, postal_code)
    values (
      new.id,
      new.raw_user_meta_data->>'first_name'::varchar,
      new.raw_user_meta_data->>'last_name'::varchar,
      new.raw_user_meta_data->>'phone'::varchar,
      new.raw_user_meta_data->>'postal_code'::varchar
    );
  insert into public.role (user_id, role) values (new.id, 'photographer');

  return new;
end;
$$ language plpgsql security definer set search_path = auth, public;

-- TRIGGERS
create trigger pda_auth_updated_at
  before update on public.pda_auth
  for each row
  execute procedure public.trigger_set_updated_at();

create trigger order_updated_at
  before update on public.order
  for each row
  execute procedure public.trigger_set_updated_at();

create trigger report_updated_at
  before update on public.report
  for each row
  execute procedure public.trigger_set_updated_at();

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Secure tables
alter table public.pda_auth enable row level security;
alter table public.profile enable row level security;
alter table public.role enable row level security;
alter table public.role_permissions enable row level security;
alter table public.order enable row level security;
alter table public.report enable row level security;

create policy "Allow individual read access" on public.profile for select using (auth.uid() = user_id);
create policy "Allow individual update access" on public.profile for update using (auth.uid() = user_id);
create policy "Allow authorized read access" on public.profile for select using (authorize('profile.read'));

create policy "Allow logged-in read access" on public.order for select using (auth.role() = 'authenticated');
create policy "Allow authorized create access" on public.order for select using (authorize('order.create'));
create policy "Allow authorized read access" on public.order for select using (authorize('order.read'));
create policy "Allow authorized update access" on public.order for update using (authorize('order.update'));
create policy "Allow authorized delete access" on public.order for delete using (authorize('order.delete'));


create policy "Allow individual read access" on public.report for select using (auth.uid() = user_id);
create policy "Allow individual update access" on public.report for update using (auth.uid() = user_id);
create policy "Allow authorized create access" on public.report for select using (authorize('report.create'));
create policy "Allow authorized read access" on public.report for select using (authorize('report.read'));
create policy "Allow authorized update access" on public.report for update using (authorize('report.update'));
create policy "Allow authorized delete access" on public.report for delete using (authorize('report.delete'));

/**
 * SEED HELPER FUNCTIONS
 * Create test user helper method.
 */
create or replace function public.create_user(
  raw_user_meta_data jsonb
) returns uuid
  security definer
  set search_path = auth
as $$
  declare
    user_id uuid;
    encrypted_pw text;
    app_metadata jsonb;
    confirmation_timestamp timestamp;
    email varchar;
begin
  user_id := extensions.uuid_generate_v4();
  raw_user_meta_data := jsonb_set(raw_user_meta_data, '{sub}', to_jsonb(user_id));
  email := raw_user_meta_data->>'email'::varchar;

  -- pw := 'Test@2795';
  encrypted_pw := '$2a$10$dwN04ae8jy5Eid34Ml/TFe.QcVWxF8DFJv/lS0vPJnZnJ6IEeiYGm';
  app_metadata := '{"provider":"email","providers":["email"]}'::jsonb;
  confirmation_timestamp := now();

  insert into auth.users
    (
      instance_id,
      id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      confirmation_sent_at,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at,
      confirmation_token,
      email_change,
      email_change_token_new,
      recovery_token
    )
  values
    (
      '00000000-0000-0000-0000-000000000000',
      user_id,
      'authenticated',
      'authenticated',
      email,
      encrypted_pw,
      confirmation_timestamp, -- email_confirmed_at
      confirmation_timestamp, -- confirmation_sent_at
      app_metadata,
      raw_user_meta_data,
      now(), -- created_at
      now(), -- updated_at
      '', -- confirmation_token
      '', -- email_change
      '', -- email_change_token_new
      '' -- recovery_token
    )
  returning id into user_id;

  insert into auth.identities 
    (
      provider_id,
      user_id,
      identity_data,
      provider,
      last_sign_in_at,
      created_at,
      updated_at
    )
  values
    (
      extensions.uuid_generate_v4(),
      user_id,
      format('{"sub":"%s","email":"%s"}', user_id::text, email)::jsonb,
      'email',
      now(),
      now(),
      now()
    );

  return user_id;
end;
$$ language plpgsql;
